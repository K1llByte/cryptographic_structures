

# This file was *autogenerated* from the file ntru.sage
from sage.all_cmdline import *   # import sage library

_sage_const_509 = Integer(509); _sage_const_3 = Integer(3); _sage_const_2000 = Integer(2000); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_256 = Integer(256); _sage_const_0 = Integer(0)
from random import choice
from cryptography.hazmat.primitives import hashes 

N = _sage_const_509 
p = _sage_const_3 
#log_q = 11
#q = 1 << log_q # 2048
q = next_prime(_sage_const_2000 )

Z = ZZ['w']; (w,) = Z._first_ngens(1)
R = QuotientRing(Z , Z.ideal(w**N - _sage_const_1 ), names=('w',)); (w,) = R._first_ngens(1)
#print(R)

Q = Integers(q)['w']; (w,) = Q._first_ngens(1)
Rq = QuotientRing(Q , Q.ideal(w**N - _sage_const_1 ), names=('w',)); (w,) = Rq._first_ngens(1)

# Mensagem é dada num intervalo de coeficientes [0, q-1],
# por isso o modulo dos valores tem de ser recentrados
# para o intervalo [-q/2, q/2-1].
def centered(l,p):
    fp = [ lift(Mod(a,p)) for a in l ]
    return [ u if (u <= p//_sage_const_2 ) else u-p for u in fp ]

class NTRU:
    def __init__(self, N, p, q):
        self.N = N
        self.p = p
        self.q = q
        # KeyGen quando instancia NTRU
        # f tem de ser invertivel
        while True:
            self.f = _sage_const_1  + self.p * R(self.random_poly_ternary())
            if Rq(list(self.f)).is_unit():
                break
        self.g = self.p * R(self.random_poly_ternary())
        fq = Rq(list(self.f)).inverse_of_unit()
        hq = fq * Rq(list(self.g))
        self.h = R([lift(a) for a in list(hq)])

    def encrypt(self, msg):
        r = R(self.random_poly_ternary())
        m = R(msg)
        return centered(list(self.h*r + m), self.q)

    def decrypt(self, enc):
        e = R(enc)
        a = centered(list(self.f * e), self.q)
        return centered(list(R(a)),self.p)

    def encapsulate(self):
        rm = self.random_poly_ternary()
        sha3 = hashes.Hash(hashes.SHAKE256(int(_sage_const_256 )))
        # + p // 2 porque nao dá para converter de imediato
        # valores inteiros negativos para complemento para 2
        # só sao considerados os valores unsigned
        sha3.update(bytes([ c + self.p // _sage_const_2  for c in rm ]))
        shared_key = sha3.finalize()
        return (shared_key, self.encrypt(rm))

    def decapsulate(self,cipher):
        rm = self.decrypt(cipher)
        sha3 = hashes.Hash(hashes.SHAKE256(int(_sage_const_256 )))
        # + p // 2 porque nao dá para converter de imediato
        # valores inteiros negativos para complemento para 2
        # só sao considerados os valores unsigned
        sha3.update(bytes([ c + self.p // _sage_const_2  for c in rm ]))
        return sha3.finalize()

    def random_poly_ternary(self):
        return [ choice([-_sage_const_1 ,_sage_const_0 ,_sage_const_1 ]) for i in range(self.N) ]

ntru = NTRU(N,p,q)

# NTRU PKE Test
# msg = ntru.random_poly_ternary()
# enc = ntru.encrypt(msg)
# dec = ntru.decrypt(enc)
# print("NTRU PKE Test:",msg == dec)

# # NTRU KEM Test
# bob_shared_secret, enc = ntru.encapsulate()
# alice_shared_secret = ntru.decapsulate(enc)
# print("NTRU KEM Test:",bob_shared_secret == alice_shared_secret)


poly = ntru.random_poly_ternary()
print("poly",poly)
poly_mod = [ Mod(a,p) for a in poly ]
print("Mod",poly_mod)
poly_lift = [ lift(a) for a in poly_mod ]
print("lift",poly_lift)

