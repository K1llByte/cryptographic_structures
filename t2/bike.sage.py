

# This file was *autogenerated* from the file bike.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_257 = Integer(257); _sage_const_16 = Integer(16); _sage_const_3 = Integer(3); _sage_const_256 = Integer(256)
import random as rn
from cryptography.hazmat.primitives import hashes
import numpy as np

K = GF(_sage_const_2 )
um = K(_sage_const_1 )
zero = K(_sage_const_0 )

r = _sage_const_257 
n = _sage_const_2 *r
t = _sage_const_16 

Vn  = VectorSpace(K,n)
Vr  = VectorSpace(K,r)

def mask(u,v): 
    return u.pairwise_product(v)

def hamm(u):                                     ## peso de Hamming
    return sum([int(a == um) for a in u])

# Matrizes circulantes de tamanho r com r primo

R = PolynomialRing(K, names=('w',)); (w,) = R._first_ngens(1)
Rr = QuotientRing(R,R.ideal(w**r+_sage_const_1 ))

def rot(h):
    v = Vr() ; v[_sage_const_0 ] = h[-_sage_const_1 ]
    for i in range(r-_sage_const_1 ):
        v[i+_sage_const_1 ] = h[i]
    return v

def Rot(h):
    M = Matrix(K,r,r)
    M[_sage_const_0 ] = expand(h)
    for i in range(_sage_const_1 ,r):
        M[i] = rot(M[i-_sage_const_1 ])
    return M

def expand(f):
    fl = f.list(); ex = r - len(fl)
    return Vr(fl + [zero]*ex)

def expand2(code):
    (f0,f1) = code
    f = expand(f0).list() + expand(f1).list()
    return Vn(f)

def unexpand2(vec):
    u = vec.list()
    return (Rr(u[:r]),Rr(u[r:]))

# Uma implementação do algoritmo Bit Flip sem quaisquer optimizações
def BF(H,code,synd,cnt_iter=r, errs=_sage_const_0 ):

    mycode = code
    mysynd = synd

    while cnt_iter > _sage_const_0  and hamm(mysynd) > errs:
        cnt_iter   = cnt_iter - _sage_const_1 
        
        unsats     = [hamm(mask(mysynd,H[i])) for i in range(n)]
        max_unsats = max(unsats)
        
        for i in range(n):
            if unsats[i] == max_unsats:
                mycode[i]  += um               ## bit-flip
                mysynd     += H[i]

    if cnt_iter == _sage_const_0 :
        raise ValueError("BF: limite de iterações ultrapassado")
    
    return mycode


#sparse polynomials of size r

# produz sempre um polinómio mónico com o último coeficiente igual a 1
# o parametro "sparse > 0"  é o numero de coeficientes não nulos sem contar com o primeiro e o ultimo

def sparse_pol(sparse=_sage_const_3 ):
    coeffs = [_sage_const_1 ]*sparse + [_sage_const_0 ]*(r-_sage_const_2 -sparse)
    rn.shuffle(coeffs)
    return Rr([_sage_const_1 ]+coeffs+[_sage_const_1 ])

## Noise
# produz um par de polinomios dispersos de tamanho "r" com um dado número total de erros "t"

def noise(t):
    el = [um]*t + [zero]*(n-t)
    rn.shuffle(el)  
    return (Rr(el[:r]),Rr(el[r:]))


# def bikeKG():
#     while True:
#         h0 = sparse_pol(); h1 = sparse_pol()
#         if h0 != h1 and h0.is_unit() and h1.is_unit():
#             break

#     h = (h0,h1)                          # chave privada
#     g = (1, h0/h1)                       # chave pública para um código sistemático
#     return (g,h)

# def bikeEncrypt(g,msg=None):
#     (g0,g1) = g 
#     (e0,e1) = noise(t)
#     if msg != None:
#         m = msg
#         return (m * g0 + e0, m * g1 + e1)       # Modelo McEliece PKE
#     else:
#         m = Rr.random_element()
#         key = mk_key((e0,e1))
#         enc = (m * g0 + e0, m * g1 + e1)
#         return (key,enc)                         # Modelo KEM

# def bikeDecrypt(h,crypt,kem=False):
#     code = expand2(crypt)                   # converter para vetor
    
#     (h0,h1) = h                             # a partir da chave privada gera a matriz de paridades
#     H = block_matrix(2,1,[Rot(h0),Rot(h1)])
#     synd = code * H                         # calcula o sindroma
    
#     cw = BF(H,code,synd)                    # descodifica usando BitFlip em vetores
    
#     (cw0,cw1) = unexpand2(cw)               # passar a polinómios
#     assert cw1*h1 == cw0*h0                 # confirmação
    
#     if not kem:
#         return cw0                 # como é um código sistemático a primeira componente da cw é a mensagem
#     else:                          # modelo KEM
#         enc0 , enc1 = crypt
#         return mk_key((cw0 + enc0 , cw1 + enc1))


class BIKE:
    def __init__(self):
        while True:
            h0 = sparse_pol()
            h1 = sparse_pol()
            if (h0 != h1 and h0.is_unit()) and (h1.is_unit()):
                break
        self.h = (h0,h1)
        self.g = (_sage_const_1 , h0/h1)

    def encrypt(self, msg):
        (g0,g1) = self.g
        (e0,e1) = noise(t)
        # Modelo McEliece PKE
        m = Rr(msg)
        return (m * g0 + e0, m * g1 + e1)

    def decrypt(self,enc):
        code = expand2(enc)                     # converter para vetor
        (h0,h1) = self.h                        # a partir da chave privada gera a matriz de paridades
        H = block_matrix(_sage_const_2 ,_sage_const_1 ,[Rot(h0),Rot(h1)])
        synd = code * H                         # calcula o sindroma
        cw = BF(H,code,synd)                    # descodifica usando BitFlip em vetores
        (cw0,cw1) = unexpand2(cw)               # passar a polinómios
        return list(cw0)                        # como é um código sistemático a primeira componente da cw é a mensagem

    def encapsulate(self):
        m = self.random_poly_binary()
        sha3 = hashes.Hash(hashes.SHAKE256(int(_sage_const_256 )))
        sha3.update(bytes(m))
        shared_key = sha3.finalize()
        return (shared_key, self.encrypt(m))

    def decapsulate(self,enc):
        m = self.decrypt(enc)
        sha3 = hashes.Hash(hashes.SHAKE256(int(_sage_const_256 )))
        sha3.update(bytes(m))
        return sha3.finalize()

    def random_poly_binary(self):
        return [ choice([_sage_const_0 ,_sage_const_1 ]) for i in range(r) ]

bike = BIKE()

# BIKE PKE Test
msg = bike.random_poly_binary()
enc = bike.encrypt(msg)
dec = bike.decrypt(enc)
print("BIKE PKE Test:",msg == dec)

# BIKE KEM Test
bob_shared_secret, enc = bike.encapsulate()
# print("bob",bob_shared_secret)
alice_shared_secret = bike.decapsulate(enc)
# print("alice",alice_shared_secret)

print("BIKE KEM Test:",bob_shared_secret == alice_shared_secret)

